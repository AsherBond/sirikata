#Copyright (c) 2008, Patrick Reiter Horn
#All rights reserved.
#
#Redistribution and use in source and binary forms, with or without
#modification, are permitted provided that the following conditions are met: 
#
#    * Redistributions of source code must retain the above copyright notice,
#      this list of conditions and the following disclaimer. 
#    * Redistributions in binary form must reproduce the above copyright notice,
#      this list of conditions and the following disclaimer in the documentation
#      and/or other materials provided with the distribution. 
#    * Neither the name of the Sirikata nor the names of its contributors
#      may be used to endorse or promote products derived from this software
#      without specific prior written permission. 
#
#THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
#ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
#ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
#LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
#ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
#SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#cmake options

CMAKE_MINIMUM_REQUIRED(VERSION 2.4)
SET(CMAKE_VERBOSE_MAKEFILE OFF)
SET(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS TRUE)

IF(COMMAND CMAKE_POLICY)
  # Use new policy for absolute path libraries.  We have no reason to depend on the
  # old version which adds library search paths unnecessarily
  CMAKE_POLICY(SET CMP0003 NEW)
ENDIF(COMMAND CMAKE_POLICY)


IF(WIN32)
ADD_DEFINITIONS(-D_CRT_SECURE_NO_WARNINGS -D_SCL_SECURE_NO_WARNINGS -EHsc -DBOOST_ALL_DYN_LINK -Ycutil/Platform.hh)
SET(CMAKE_CXX_FLAGS "-D_CRT_SECURE_NO_WARNINGS -D_SCL_SECURE_NO_WARNINGS -Ycutil/Platform.hh")
#-fno-rtti
SET(CMAKE_CXX_FLAGS_DEFAULT "-g -D_CRT_SECURE_NO_WARNINGS -D_SCL_SECURE_NO_WARNINGS -Ycutil/Platform.hh" CACHE STRING
    "Built cxxflags with default settings."
    FORCE )
SET( CMAKE_C_FLAGS_DEFAULT "-g -Wall -D_CRT_SECURE_NO_WARNINGS -D_SCL_SECURE_NO_WARNINGS -Ycutil/Platform.hh" CACHE STRING
    "Built cflags with default settings."
    FORCE )

ELSE()

IF(NOT CMAKE_BUILD_TYPE)
#the below lines work around a bug when cmake first is configured without <CONFIG>
  SET(FORCE_USE_DEBUG_LOCATION "TRUE")
  SET(CMAKE_BUILD_TYPE Debug CACHE STRING
      "Build types include: Default Debug Release None RelWithDebInfo." FORCE
      )
ENDIF()
STRING(TOUPPER ${CMAKE_BUILD_TYPE} UPPERCASE_BUILD_TYPE)
STRING(COMPARE EQUAL ${UPPERCASE_BUILD_TYPE} "DEBUG" ISDEBUG)

SET(ADDED_DEFINITIONS -Wall -Wno-unused-function -Wno-unused-variable -fvisibility=hidden)
#-fno-rtti
ADD_DEFINITIONS(${ADDED_DEFINITIONS})
#-fno-rtti
SET(CMAKE_CXX_FLAGS_DEFAULT "-g -Wall -Wno-unused-function -Wno-unused-variable -fvisibility=hidden" CACHE STRING
    "Built cxxflags with default settings."
    FORCE )
SET( CMAKE_C_FLAGS_DEFAULT "-g -Wall -Wno-unused-function -Wno-unused-variable -fvisibility=hidden" CACHE STRING
    "Built cflags with default settings."
    FORCE )
ENDIF()
SET( CMAKE_EXE_LINKER_FLAGS_DEFAULT
    "" CACHE STRING
    "Linking binaries with default settings."
    FORCE )
SET( CMAKE_SHARED_LINKER_FLAGS_DEFAULT
    "" CACHE STRING
    "Building shared libraries with default settings."
    FORCE )
MARK_AS_ADVANCED(
    CMAKE_CXX_FLAGS_DEFAULT
    CMAKE_C_FLAGS_DEFAULT
    CMAKE_EXE_LINKER_FLAGS_DEFAULT
    CMAKE_SHARED_LINKER_FLAGS_DEFAULT )

#project global flags

PROJECT(Sirikata CXX)

IF(NOT TOP_LEVEL)
  SET(TOP_LEVEL ${CMAKE_CURRENT_SOURCE_DIR}/../..)
ENDIF()
GET_FILENAME_COMPONENT(TOP_LEVEL ${TOP_LEVEL} ABSOLUTE)

#add-ins

IF(NOT CMAKE_MODULE_PATH)
  SET(CMAKE_MODULE_PATH ${TOP_LEVEL}/build/modules)
ENDIF()
GET_FILENAME_COMPONENT(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ABSOLUTE)

MACRO(VERIFY_VERSION package_name major minor subminor)
  IF (${package_name}_MAJOR_VERSION LESS ${major})
    MESSAGE(FATAL_ERROR "${package_name} out of date: ${major}.${minor}.${subminor}")
  ELSEIF(${package_name}_MAJOR_VERSION EQUAL ${major})
    IF(${package_name}_MINOR_VERSION LESS ${minor})
       MESSAGE(FATAL_ERROR "${package_name} out of date: ${major}.${minor}.${subminor}")
    ELSEIF(${package_name}_MINOR_VERSION EQUAL ${major})
      IF(${package_name}_SUBMINOR_VERSION LESS ${subminor})
        MESSAGE(FATAL_ERROR "${package_name} out of date: ${major}.${minor}.${subminor}")
      ENDIF()
    ENDIF()
  ENDIF()
ENDMACRO(VERIFY_VERSION)


MACRO(CAR var)
  SET(${var} ${ARGV1})
ENDMACRO(CAR)
MACRO(CDR var junk)
  SET(${var} ${ARGN})
ENDMACRO(CDR)

MACRO(LIST_CONTAINS var value)
  SET(${var})
  FOREACH (value2 ${ARGN})
    IF (${value} STREQUAL ${value2})
      SET(${var} TRUE)
    ENDIF (${value} STREQUAL ${value2})
  ENDFOREACH (value2)
ENDMACRO(LIST_CONTAINS)

MACRO(PARSE_ARGUMENTS prefix arg_names option_names)
  SET(DEFAULT_ARGS)
  FOREACH(arg_name ${arg_names})
    SET(${prefix}_${arg_name})
  ENDFOREACH(arg_name)
  FOREACH(option ${option_names})
    SET(${prefix}_${option} FALSE)
  ENDFOREACH(option)

  SET(current_arg_name DEFAULT_ARGS)
  SET(current_arg_list)
  FOREACH(arg ${ARGN})
    LIST_CONTAINS(is_arg_name ${arg} ${arg_names})
    IF (is_arg_name)
      SET(${prefix}_${current_arg_name} ${current_arg_list})
      SET(current_arg_name ${arg})
      SET(current_arg_list)
    ELSE (is_arg_name)
      LIST_CONTAINS(is_option ${arg} ${option_names})
      IF (is_option)
	SET(${prefix}_${arg} TRUE)
      ELSE (is_option)
	SET(current_arg_list ${current_arg_list} ${arg})
      ENDIF (is_option)
    ENDIF (is_arg_name)
  ENDFOREACH(arg)
  SET(${prefix}_${current_arg_name} ${current_arg_list})
ENDMACRO(PARSE_ARGUMENTS)

MACRO(ADD_PROTOCOLBUFFERS_CPP_TARGET)
  PARSE_ARGUMENTS(PROTOCOLBUFFERS "DEPENDS;IMPORTS;OUTPUTDIR;INPUTDIR" "" ${ARGN})
  CAR(PROTOCOLBUFFERS_NAME ${PROTOCOLBUFFERS_DEFAULT_ARGS})
  CDR(PROTOCOLBUFFERS_FILES ${PROTOCOLBUFFERS_DEFAULT_ARGS})
  SET(PROTOCOLBUFFERS_PROTO_TARGET ${PROTOCOLBUFFERS_NAME})

  SET(PROTOCOLBUFFERS_PROTO_FILES)
  SET(PROTOCOLBUFFERS_CPP_FILES)
  SET(PROTOCOLBUFFERS_H_FILES)
  SET(PROTOCOLBUFFERS_ALL_OUTPUTS)

  SET(PROTOCOLBUFFERS_OPTIONS)
  IF(PROTOCOLBUFFERS_IMPORTS)
    SET(PROTOCOLBUFFERS_OPTIONS ${PROTOCOLBUFFERS_OPTIONS} --proto_path=${PROTOCOLBUFFERS_IMPORTS})
  ENDIF(PROTOCOLBUFFERS_IMPORTS)
  IF(PROTOCOLBUFFERS_OUTPUTDIR)
    SET(PROTOCOLBUFFERS_OPTIONS ${PROTOCOLBUFFERS_OPTIONS} --cpp_out=${PROTOCOLBUFFERS_OUTPUTDIR})
  ENDIF(PROTOCOLBUFFERS_OUTPUTDIR)


  FOREACH(FILE ${PROTOCOLBUFFERS_FILES})
    SET(PROTOCOLBUFFERS_PROTO_FILE ${PROTOCOLBUFFERS_INPUTDIR}/${FILE}.proto)
    SET(PROTOCOLBUFFERS_CPP_FILE ${PROTOCOLBUFFERS_OUTPUTDIR}/${FILE}.pb.cc)
    SET(PROTOCOLBUFFERS_H_FILE ${PROTOCOLBUFFERS_OUTPUTDIR}/${FILE}.pb.h)
    SET(PROTOCOLBUFFERS_OUTPUTS ${PROTOCOLBUFFERS_H_FILE} ${PROTOCOLBUFFERS_CPP_FILE})

    SET(PROTOCOLBUFFERS_PROTO_FILES ${PROTOCOLBUFFERS_PROTO_FILES} ${PROTOCOLBUFFERS_PROTO_FILE})
    SET(PROTOCOLBUFFERS_CPP_FILES ${PROTOCOLBUFFERS_CPP_FILES} ${PROTOCOLBUFFERS_CPP_FILE})
    SET(PROTOCOLBUFFERS_H_FILES ${PROTOCOLBUFFERS_H_FILES} ${PROTOCOLBUFFERS_H_FILE})
    SET(PROTOCOLBUFFERS_ALL_OUTPUTS ${PROTOCOLBUFFERS_ALL_OUTPUTS} ${PROTOCOLBUFFERS_OUTPUTS})

    ADD_CUSTOM_COMMAND(OUTPUT ${PROTOCOLBUFFERS_H_FILE} ${PROTOCOLBUFFERS_CPP_FILE}
                       COMMAND ${PROTOCOLBUFFERS_COMPILER} ${PROTOCOLBUFFERS_OPTIONS} ${PROTOCOLBUFFERS_PROTO_FILE}
                       DEPENDS ${PROTOCOLBUFFERS_PROTO_FILE} ${PROTOCOLBUFFERS_DEPENDS}
                       COMMENT "Building ${PROTOCOLBUFFERS_PROTO_FILE} -> ${PROTOCOLBUFFERS_OUTPUTS}")
  ENDFOREACH(FILE)
ENDMACRO(ADD_PROTOCOLBUFFERS_CPP_TARGET)


MACRO(ADD_CXXTEST_CPP_TARGET)
  PARSE_ARGUMENTS(CXXTEST "DEPENDS;OUTPUTDIR;LIBRARYDIR" "" ${ARGN})
  CAR(CXXTEST_NAME ${CXXTEST_DEFAULT_ARGS})
  CDR(CXXTEST_FILES ${CXXTEST_DEFAULT_ARGS})

  SET(CXXTEST_EXEC_TARGET ${CXXTEST_NAME})

  SET(CXXTEST_TEST_FILES)
  SET(CXXTEST_H_FILES)

  SET(CXXTEST_OPTIONS --runner=StdioPrinter)
  #IF(CXXTEST_OUTPUTDIR)
  #  SET(CXXTEST_OPTIONS ${CXXTEST_OPTIONS} -o ${CXXTEST_OUTPUTDIR})
  #ENDIF(CXXTEST_OUTPUTDIR)
  FIND_PACKAGE(Perl)
  IF(PERL_EXECUTABLE)
    SET(CXXTEST_COMPILER ${PERL_EXECUTABLE})
    SET(CXXTEST_GEN ${CXXTEST_LIBRARYDIR}/cxxtestgen.pl)
  ELSE()
    FIND_PACKAGE(PythonInterp)
    IF(PYTHON_EXECUTABLE)
      SET(CXXTEST_COMPILER ${PYTHON_EXECUTABLE})
      SET(CXXTEST_GEN ${CXXTEST_LIBRARYDIR}/cxxtestgen.py)    
    ELSE()
      MESSAGE("!!! Cannot locate python or perl -- tests will not be compiled.")
    ENDIF()
  ENDIF()
  SET(CXXTEST_CPP_FILE ${CXXTEST_OUTPUTDIR}/test.cc)
  FOREACH(FILE ${CXXTEST_FILES})
    SET(CXXTEST_H_FILE ${FILE})
    SET(CXXTEST_TEST_FILES ${CXXTEST_TEST_FILES} ${CXXTEST_H_FILE})
  ENDFOREACH(FILE)
  IF (CXXTEST_COMPILER)
    SET(FINAL_CXXTEST_COMMAND ${CXXTEST_COMPILER} ${CXXTEST_GEN} ${CXXTEST_OPTIONS} -o ${CXXTEST_CPP_FILE} ${CXXTEST_TEST_FILES})
    ADD_CUSTOM_COMMAND(OUTPUT ${CXXTEST_CPP_FILE}
                       COMMAND ${FINAL_CXXTEST_COMMAND}
                       DEPENDS ${CXXTEST_TEST_FILES} ${CXXTEST_DEPENDS}
                       COMMENT "Building ${CXXTEST_TEST_FILES} -> ${CXXTEST_CPP_FILE}")
  ELSE()
    ADD_CUSTOM_COMMAND(OUTPUT ${CXXTEST_CPP_FILE}
                       COMMAND exit 1
                       COMMENT "Unable to build ${CXXTEST_CPP_FILE} because python and perl were not found.")
  ENDIF()

  SET_DIRECTORY_PROPERTIES(PROPERTIES ADDITIONAL_MAKE_CLEAN_FILES ${CXXTEST_CPP_FILE})

ENDMACRO(ADD_CXXTEST_CPP_TARGET)

#dependencies
IF(NOT PLATFORM_LIBS)
  SET(PLATFORM_LIBS ${TOP_LEVEL}/dependencies/)
  GET_FILENAME_COMPONENT(PLATFORM_LIBS ${PLATFORM_LIBS} ABSOLUTE)
  IF(NOT PLATFORM_LIBS)
    MESSAGE(STATUS "Could not find dependencies directory ${TOP_LEVEL}/dependencies/")
  ENDIF()
ENDIF()

#libraries

#dependency: protocolbuffers
IF(APPLE)
SET(PROTOCOLBUFFERS_ROOT ${PLATFORM_LIBS})
ELSE()
SET(PROTOCOLBUFFERS_ROOT ${PLATFORM_LIBS}/protobufs)
ENDIF()
FIND_PACKAGE(ProtocolBuffers)
IF(NOT PROTOCOLBUFFERS_FOUND)
  MESSAGE(FATAL_ERROR "Cannot find Protocol Buffers")
ENDIF()


#dependency: boost > 1.35
IF(NOT BOOST_ROOT)
  IF(WIN32)
    SET(BOOST_ROOT ${PLATFORM_LIBS})
#    SET(Boost_USE_STATIC_LIBS ON)
  ENDIF()
  IF(APPLE)
    SET(BOOST_ROOT ${PLATFORM_LIBS})
  ENDIF()
ENDIF()
SET(Boost_FIND_REQUIRED TRUE)
IF(WIN32)
FIND_PACKAGE(Boost COMPONENTS system program_options thread filesystem)
ELSE(WIN32)
FIND_PACKAGE(Boost COMPONENTS system)
#STRING(REPLACE "boost_system" "boost_signals" Boost_SIGNALS_LIBRARY ${Boost_SYSTEM_LIBRARY})
STRING(REPLACE "boost_system" "boost_program_options" Boost_PROGRAM_OPTIONS_LIBRARY ${Boost_SYSTEM_LIBRARY})
STRING(REPLACE "boost_system" "boost_thread" Boost_THREAD_LIBRARY ${Boost_SYSTEM_LIBRARY})
STRING(REPLACE "boost_system" "boost_filesystem" Boost_FILESYSTEM_LIBRARY ${Boost_SYSTEM_LIBRARY})
ENDIF(WIN32)
VERIFY_VERSION(Boost 1 35 0)

SET(Boost_LIBRARIES
    ${Boost_PROGRAM_OPTIONS_LIBRARY}
    ${Boost_SYSTEM_LIBRARY}
    ${Boost_THREAD_LIBRARY}
    ${Boost_FILESYSTEM_LIBRARY})

#dependency: curl
IF(NOT CURL_ROOT)
  IF(WIN32)
    SET(CURL_ROOT ${PLATFORM_LIBS}/libcurl_7_18_0)
    GET_FILENAME_COMPONENT(CURL_ROOT ${CURL_ROOT} ABSOLUTE)
    IF(NOT CURL_ROOT)
      SET(CURL_ROOT ${PLATFORM_LIBS}/libcurl_7_15_5)
    ENDIF()
  ELSEIF(APPLE)
    SET(CURL_ROOT ${PLATFORM_LIBS})
  ENDIF()
ENDIF()

FIND_PACKAGE(CURL)
SET(TEST_LIBRARIES ${CURL_LIBRARIES})

#dependency: cxxtest
SET(CXXTESTRoot ${TOP_LEVEL}/externals/cxxtest)


#project directory locations
SET(LIBCORE_DIR ${TOP_LEVEL}/libcore)
SET(LIBSPACE_DIR ${TOP_LEVEL}/libspace)
SET(LIBOH_DIR ${TOP_LEVEL}/liboh)
SET(SPACE_DIR ${TOP_LEVEL}/space)
SET(CPPOH_DIR ${TOP_LEVEL}/cppoh)

#include locations
SET(LIBSPACE_INCLUDE_DIR ${LIBSPACE_DIR}/include)
SET(LIBOH_INCLUDE_DIR ${LIBOH_DIR}/include)

#source file locations
SET(LIBCORE_SOURCE_DIR ${LIBCORE_DIR}/src)
SET(LIBSPACE_SOURCE_DIR ${LIBSPACE_DIR}/src)
SET(LIBOH_SOURCE_DIR ${LIBOH_DIR}/src)
SET(SPACE_SOURCE_DIR ${SPACE_DIR}/src)
SET(CPPOH_SOURCE_DIR ${CPPOH_DIR}/src)


#cxx flags
# FIXME these include directories should be project specific

SET(INCLUDE_DIRECTORIES
  ${LIBCORE_SOURCE_DIR}
  ${LIBSPACE_INCLUDE_DIR}
  ${LIBOH_INCLUDE_DIR}
  ${SPACE_SOURCE_DIR}
  ${CPPOH_SOURCE_DIR}
  ${Boost_INCLUDE_DIRS}
  ${CURL_INCLUDE_DIRS}
  ${PROTOCOLBUFFERS_INCLUDE_DIRS}
  ${CXXTESTRoot})

INCLUDE_DIRECTORIES(BEFORE ${INCLUDE_DIRECTORIES})

SET(INCLUDE_COMMAND)
FOREACH(INCLUDE_NONCE ${INCLUDE_DIRECTORIES})
  SET(INCLUDE_COMMAND  ${INCLUDE_COMMAND} -I${INCLUDE_NONCE})
ENDFOREACH(INCLUDE_NONCE)

#protocol buffers preprocessing
SET(ProtocolBuffersRoot ${LIBCORE_DIR}/protocol)
SET(ProtocolBuffersSources
  FloatVector3
  DoubleVector3
  FloatQuaternion
)

SET(SirikataProtocolBuffersSources)
FOREACH(protosource ${ProtocolBuffersSources})
  SET(SirikataProtocolBuffersSources ${SirikataProtocolBuffersSources}
                       ${LIBCORE_SOURCE_DIR}/${protosource}.pb.cc)
ENDFOREACH(protosource)

ADD_PROTOCOLBUFFERS_CPP_TARGET(PROTOCOLBUFFERS ${ProtocolBuffersSources} INPUTDIR ${ProtocolBuffersRoot} IMPORTS ${ProtocolBuffersRoot} OUTPUTDIR ${LIBCORE_SOURCE_DIR})

#source files

SET(SIRIKATA_CORE_SOURCES
    ${SirikataProtocolBuffersSources}
	${LIBCORE_SOURCE_DIR}/transfer/HTTPRequest.cpp
	${LIBCORE_SOURCE_DIR}/transfer/DiskCache.cpp
	${LIBCORE_SOURCE_DIR}/task/EventManager.cpp
	${LIBCORE_SOURCE_DIR}/task/Event.cpp
	${LIBCORE_SOURCE_DIR}/task/UniqueId.cpp
	${LIBCORE_SOURCE_DIR}/task/Time.cpp
   	${LIBCORE_SOURCE_DIR}/options/Options.cpp
	${LIBCORE_SOURCE_DIR}/network/Stream.cpp
	${LIBCORE_SOURCE_DIR}/network/TCPStream.cpp
	${LIBCORE_SOURCE_DIR}/network/TCPStreamListener.cpp
	${LIBCORE_SOURCE_DIR}/util/DynamicLibrary.cpp
	${LIBCORE_SOURCE_DIR}/util/internal_sha2.cpp
	${LIBCORE_SOURCE_DIR}/util/Plugin.cpp
	${LIBCORE_SOURCE_DIR}/util/PluginManager.cpp
	${LIBCORE_SOURCE_DIR}/util/Quaternion.cpp
	${LIBCORE_SOURCE_DIR}/util/Sha256.cpp
	${LIBCORE_SOURCE_DIR}/util/ThreadSafeQueue.cpp
	${LIBCORE_SOURCE_DIR}/util/UUID.cpp
)
#precompiled header
IF(NOT WIN32)
  SET(SIRIKATA_CORE_SOURCES	
     ${LIBCORE_SOURCE_DIR}/util/Platform.hh.gch ${SIRIKATA_CORE_SOURCES})
  SET_DIRECTORY_PROPERTIES(PROPERTIES ADDITIONAL_MAKE_CLEAN_FILES
    ${LIBCORE_SOURCE_DIR}/util/Platform.hh.gch)

  SET(PCH_INPUT ${LIBCORE_SOURCE_DIR}/util/Platform.hh)
  SET(PCH_OUTPUT ${LIBCORE_SOURCE_DIR}/util/Platform.hh.gch)
  IF(ISDEBUG)
    SET(PCH_CXX_FLAGS  ${CMAKE_CXX_FLAGS_DEBUG} )
  ELSE()
    SET(PCH_CXX_FLAGS  ${CMAKE_CXX_FLAGS_RELEASE} )
  ENDIF()
  SEPARATE_ARGUMENTS(PCH_CXX_FLAGS)
  SET(FINAL_COMMAND ${CMAKE_CXX_COMPILER} ${PCH_CXX_FLAGS} ${INCLUDE_COMMAND} ${ADDED_DEFINITIONS} ${PCH_INPUT})
  ADD_CUSTOM_COMMAND(OUTPUT ${PCH_OUTPUT}
                     COMMAND ${FINAL_COMMAND}
                     DEPENDS ${PCH_INPUT}
                     COMMENT "${FINAL_COMMAND}")
#  ADD_DEPENDENCIES(${SIRIKATA_CORE_LIB} ${PCH_OUTPUT})

ENDIF()

SET(LIBSPACE_SOURCES ${LIBSPACE_SOURCE_DIR}/Space.cpp )
SET(LIBOH_SOURCES ${LIBOH_SOURCE_DIR}/ObjectHost.cpp )
SET(SPACE_SOURCES ${SPACE_SOURCE_DIR}/main.cpp )
SET(CPPOH_SOURCES ${CPPOH_SOURCE_DIR}/main.cpp )

#test source files
SET(CXXTESTSources
  ${LIBCORE_DIR}/test/TR1Test.hpp
  ${LIBCORE_DIR}/test/AnyTest.hpp
  ${LIBCORE_DIR}/test/AtomicTest.hpp
  ${LIBCORE_DIR}/test/Vector3Test.hpp 
  ${LIBCORE_DIR}/test/Matrix3Test.hpp 
  ${LIBCORE_DIR}/test/QuaternionTest.hpp 
  ${LIBCORE_DIR}/test/EventTest.hpp
  ${LIBCORE_DIR}/test/OptionTest.hpp
  ${LIBCORE_DIR}/test/NameLookupTest.hpp
  ${LIBCORE_DIR}/test/TransferTest.hpp
 )

ADD_CXXTEST_CPP_TARGET(CXXTEST ${CXXTESTSources}
	LIBRARYDIR ${CXXTESTRoot}
	OUTPUTDIR ${CMAKE_CURRENT_BINARY_DIR})

SET(TEST_SOURCES ${CXXTEST_CPP_FILE})


#linker flags
SET(CMAKE_DEBUG_POSTFIX "_d")
SET(CMAKE_INCLUDE_PATH ${CMAKE_INCLUDE_PATH} /usr/local)
SET(CMAKE_LIBRARY_PATH ${CMAKE_LIBRARY_PATH} /usr/local)

LINK_DIRECTORIES(${Boost_LIBRARY_DIRS})

IF(WIN32)
  SET(SYSTEM_DL_LIBRARY "wsock32")
ELSE()
  SET(SYSTEM_DL_LIBRARY "dl")
ENDIF()

SET(SIRIKATA_CORE_LIBRARIES
    ${Boost_LIBRARIES}
    ${SYSTEM_DL_LIBRARY})



SET(SIRIKATA_CORE_LIB sirikata-core)
SET(SIRIKATA_SPACE_LIB sirikata-space)
SET(SIRIKATA_OH_LIB sirikata-oh)
SET(SPACE_BINARY space)
SET(CPPOH_BINARY cppoh)
SET(TEST_BINARY tests)


#libraries
ADD_LIBRARY(${SIRIKATA_CORE_LIB} STATIC ${SIRIKATA_CORE_SOURCES})
TARGET_LINK_LIBRARIES(${SIRIKATA_CORE_LIB} ${SIRIKATA_CORE_LIBRARIES})
IF(sirikata_core_LDFLAGS)
  SET_TARGET_PROPERTIES(${SIRIKATA_CORE_LIB} PROPERTIES LINK_FLAGS ${sirikata_core_LDFLAGS})
ENDIF()

ADD_LIBRARY(${SIRIKATA_SPACE_LIB} STATIC ${LIBSPACE_SOURCES})
ADD_DEPENDENCIES(${SIRIKATA_SPACE_LIB} ${SIRIKATA_CORE_LIB})
TARGET_LINK_LIBRARIES(${SIRIKATA_SPACE_LIB} ${SIRIKATA_CORE_LIB})

ADD_LIBRARY(${SIRIKATA_OH_LIB} STATIC ${LIBOH_SOURCES})
ADD_DEPENDENCIES(${SIRIKATA_OH_LIB} ${SIRIKATA_CORE_LIB})
TARGET_LINK_LIBRARIES(${SIRIKATA_OH_LIB} ${SIRIKATA_CORE_LIB})


#binaries
ADD_EXECUTABLE(${TEST_BINARY} EXCLUDE_FROM_ALL ${TEST_SOURCES})
ADD_EXECUTABLE(${SPACE_BINARY} ${SPACE_SOURCES})
ADD_EXECUTABLE(${CPPOH_BINARY} ${CPPOH_SOURCES})

ADD_DEPENDENCIES(${TEST_BINARY} ${SIRIKATA_CORE_LIB})
ADD_DEPENDENCIES(${SPACE_BINARY} ${SIRIKATA_CORE_LIB} ${SIRIKATA_SPACE_LIB})
ADD_DEPENDENCIES(${CPPOH_BINARY} ${SIRIKATA_CORE_LIB} ${SIRIKATA_OH_LIB})

SET_TARGET_PROPERTIES(${SIRIKATA_CORE_LIB} ${SPACE_BINARY} ${CPPOH_BINARY} ${TEST_BINARY}
                      PROPERTIES 
                      DEBUG_POSTFIX "_d"  
                      DEBUG_POSTFIX "_d"
                      DEBUG_POSTFIX "_d"  
                      DEBUG_POSTFIX "_d" )
TARGET_LINK_LIBRARIES(${TEST_BINARY} ${SIRIKATA_CORE_LIB} ${TEST_LIBRARIES})
TARGET_LINK_LIBRARIES(${SPACE_BINARY} ${SIRIKATA_CORE_LIB} ${SIRIKATA_SPACE_LIB})
TARGET_LINK_LIBRARIES(${CPPOH_BINARY} ${SIRIKATA_CORE_LIB} ${SIRIKATA_OH_LIB})
IF(sirikata_LDFLAGS)
  SET_TARGET_PROPERTIES(${TEST_BINARY} PROPERTIES LINK_FLAGS ${sirikata_LDFLAGS})
  SET_TARGET_PROPERTIES(${SPACE_BINARY} PROPERTIES LINK_FLAGS ${sirikata_LDFLAGS})
  SET_TARGET_PROPERTIES(${CPPOH_BINARY} PROPERTIES LINK_FLAGS ${sirikata_LDFLAGS})
ENDIF()


#precompiled headers


#installation information
INSTALL(TARGETS 
          ${SIRIKATA_CORE_LIB}
          ${SIRIKATA_SPACE_LIB}
          ${SIRIKATA_OH_LIB}
          ${SPACE_BINARY}
          ${CPPOH_BINARY}
        RUNTIME
          DESTINATION bin
        LIBRARY
          DESTINATION lib
        ARCHIVE
          DESTINATION lib
)


INSTALL(DIRECTORY
          # note: the trailing slashes avoid prepending the directory name
          # itself to the installed files
          ${LIBCORE_SOURCE_DIR}/
          ${LIBSPACE_INCLUDE_DIR}/
          ${LIBOH_INCLUDE_DIR}/
        DESTINATION include/sirikata
        PATTERN "*.cpp" EXCLUDE
        PATTERN "*.cc" EXCLUDE
)

# get the name of the binaries for running tests
IF(WIN32)
  GET_TARGET_PROPERTY(TEST_RUNABLE ${TEST_BINARY} LOCATION)
ELSE()
  IF(ISDEBUG)
#some CRAZY bug with cmake-2.4 does not bake the _d into LOCATION
    GET_TARGET_PROPERTY(TEST_RUNABLE ${TEST_BINARY} DEBUG_LOCATION)
  ELSE()
    GET_TARGET_PROPERTY(TEST_RUNABLE ${TEST_BINARY} LOCATION)
  ENDIF()
ENDIF()

ADD_CUSTOM_TARGET(test
	DEPENDS tests
	COMMAND ${TEST_RUNABLE})
